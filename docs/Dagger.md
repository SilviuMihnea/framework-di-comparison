# Dagger

This example demonstrates how to use **Dagger** for dependency injection in a Kotlin-Ktor project.

## Setup

```kotlin
plugins {
    kotlin("kapt") version "1.7.20"
    // ... other plugins
}

dependencies {
    implementation("com.google.dagger:dagger:2.44")
    kapt("com.google.dagger:dagger-compiler:2.44")
    // ... other deps
}

```
  
## Defining components

Following interface based style, we will declare an interface than an implementation

```kotlin
interface NotificationService {
    suspend fun notify(topic: String, message: String)
}

interface Notifier // some dependency for the pur implementation

class DefaultNotificationService(
    val notifier: Notifier
) : NotificationService {
    override suspend fun notify(topic: String, message: String) {
        // empty
    }
}
```

Then, we create a Dagger module.

```kotlin
@Module
class NotificationModule {
    @Provides
    fun notifier(): Notifier {
        return object : Notifier {
            // implement methods if needed
        }
    }

    @Provides
    fun notificationService(notifier: Notifier): NotificationService {
        return DefaultNotificationService(notifier)
    }
}
```

For scoped components, like per-request or per-session we create the exact same way.
Scopes in dagger **donâ€™t** have runtime lifecycles like in Koin or Spring.

```kotlin
@Scope
@Retention(AnnotationRetention.RUNTIME)
annotation class RequestScope

@RequestScope
class SomeService @Inject constructor(
    private val repo: Repository
)
```

Then, we create dagger components, which we can separate depending on scopes (workaround):

```kotlin
@Singleton
@Component(
    modules = [
        DBModule::class,
    ]
)
interface RequestScopeComponent {
    fun orderRepository(): OrderRepository
    fun qrRepository(): QRRepository
}

@Scope
@Retention(AnnotationRetention.RUNTIME)
annotation class RequestScope

@RequestScope
@Component(
    modules = [
        NotificationModule::class,
        HandlerModule::class,
        UtilityModule::class
    ]
)
interface AppScopeComponent {
    fun idGenerator(): IdGenerator
    fun qrGenerator(): QRGenerator
    fun statusHandlerService(): StatusHandlerService
}
```

For multiple classes that override the same interface, Dagger offers support for qualifiers:

```kotlin
@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class ReadyForPickUp

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class WarehouseReady

@Module
class HandlerModule {
    @Provides
    @ReadyForPickUp
    fun readyForPickUpStatusHandler(notificationService: NotificationService): StatusHandler {
        return ReadyForPickUpStatusHandler(notificationService)
    }

    @Provides
    @WarehouseReady
    fun warehouseReadyStatusHandler(notificationService: NotificationService): StatusHandler {
        return WarehouseReadyStatusHandler(notificationService)
    }

    @Provides
    fun statusHandlerService(
        @ReadyForPickUp handler1: StatusHandler,
        @WarehouseReady handler2: StatusHandler
    ): StatusHandlerService {
        return StatusHandlerService(listOf(handler1, handler2))
    }
}
```

Afterwards, we need to build the project, and dagger will generate `DaggerAppScopeComponent` and `DaggerRequestScopeComponent`.

## Injecting dependencies

We can use annotations:

```kotlin
class ReadyForPickUpStatusHandler @Inject constructor(
    private val notificationService: NotificationService
) : StatusHandler 
```

Or directly use the classes generated by Dagger:

```kotlin
val scopeComponent = DaggerRequestScopeComponent.create()
val orderRepository = scopeComponent.orderRepository()
val qrRepository = scopeComponent.qrRepository()
```

## Testing

For testing, we add a second module that adds overrides for some of the components. \\
Koin will use the overrides for instantiating the dependents. \\
We can keep the base app module to keep the dependencies between components.

```kotlin
fun Application.configureRouting() {
    val idGenerator = DaggerAppScopeComponent.create().idGenerator()
    routing {
        get("") {
            call.respondText("Hello ${idGenerator.generate()}!")
        }
    }
}

@Component(modules = {
    NotificationModule::class,
    HandlerModule::class,
    FakeUtilityModule::class
})
interface TestAppScopeComponent extends AppScopeComponent {
  FakeAuthManager fakeAuthManager();
  FakeFooService fakeFooService();
}

// -- or --
class FakeUtilityModule extends UtilityModule {
    override fun idGenerator(): IdGenerator {
        return FakeIdGenerator()
    }
}

val fakeAppScopeComponent = DaggerAppScopeComponent.builder()
    .utilityModule(FakeUtilityModule())
    .build()

@Test
class ApplicationTest : StringSpec(
    {
        "should make a request to the app " {
            testApplication {
                application {
                    configureRouting()
                }

                val response = client.get("") // client is coming from testApplication
                response.status shouldBe HttpStatusCode.OK
                response.bodyAsText() shouldBe "Hello 03403403-4034-453e-b564-193a706dbaa8!"
            }
        }
    }
)
```

## Single, Factory, Scoped

```kotlin
@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class ReadyForPickUp

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class WarehouseReady

@Module
class DBModule {
    @Provides
    fun dbConnection(): DBConnection {
        return DBConnection()
    }

    @Provides
    fun orderRepository(db: DBConnection): OrderRepository {
        return DefaultOrderRepository(db)
    }

    @Provides
    fun qrRepository(db: DBConnection): QRRepository {
        return DefaultQRRepository(db)
    }
}

@Module
class UtilityModule {
    @Provides
    fun idGenerator(): IdGenerator {
        return DefaultIdGenerator()
    }

    @Provides
    fun qrGenerator(): QRGenerator {
        return QRGenerator { QR() }
    }
}

@Module
class NotificationModule {
    @Provides
    fun notifier(): Notifier {
        return object : Notifier {
            // implement methods if needed
        }
    }

    @Provides
    fun notificationService(notifier: Notifier): NotificationService {
        return DefaultNotificationService(notifier)
    }
}

@Module
class HandlerModule {
    @Provides
    @ReadyForPickUp
    fun readyForPickUpStatusHandler(notificationService: NotificationService): StatusHandler {
        return ReadyForPickUpStatusHandler(notificationService)
    }

    @Provides
    @WarehouseReady
    fun warehouseReadyStatusHandler(notificationService: NotificationService): StatusHandler {
        return WarehouseReadyStatusHandler(notificationService)
    }

    @Provides
    fun statusHandlerService(
        @ReadyForPickUp handler1: StatusHandler,
        @WarehouseReady handler2: StatusHandler
    ): StatusHandlerService {
        return StatusHandlerService(listOf(handler1, handler2))
    }
}


@Singleton
@Component(
    modules = [
        DBModule::class,
    ]
)
interface RequestScopeComponent {
    fun orderRepository(): OrderRepository
    fun qrRepository(): QRRepository
}

@Scope
@Retention(AnnotationRetention.RUNTIME)
annotation class RequestScope

@RequestScope
@Component(
    modules = [
        NotificationModule::class,
        HandlerModule::class,
        UtilityModule::class
    ]
)
interface AppScopeComponent {
    fun idGenerator(): IdGenerator
    fun qrGenerator(): QRGenerator
    fun statusHandlerService(): StatusHandlerService
}
```

While Dagger is a powerful and robust DI framework commonly used in large-scale applications, Koin provides simplicity and ease of use, potentially making it a better fit for certain projects. [Source: Baeldung](https://www.baeldung.com/kotlin/dagger-to-koin-migrate)
